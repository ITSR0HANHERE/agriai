# -*- coding: utf-8 -*-
"""AI_in_Agriculture.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OtxnGnDhdfY8wPS6Us65RnlRCODxP0Uu

## **Importing labiaries**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from imblearn.over_sampling import RandomOverSampler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import load_iris
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score, classification_report
from sklearn.tree import DecisionTreeClassifier
import tensorflow as tf
from sklearn.linear_model import LinearRegression

"""# Data handling and data filtering"""

cols=["Crop","Crop_Year","Season","State","Area","Production","Annual_Rainfall","Fertilizer","Pesticide","Yield"]
# Assuming 'crop_yield.csv' is in the same directory, this line should work.
# df=pd.read_csv("crop_yield.csv",sep=",",encoding="utf-8")

# If 'datafile(3).csv' is in a different directory, replace 'path/to/your/file' with the actual path.
# For example, if it's in a folder named 'data' within your current directory:
# df=pd.read_csv("data/datafile(3).csv",sep=",",encoding="utf-8")
# df=pd.read_csv("datafile (3).csv",sep=",",encoding="utf-8")

# Assuming 'Crop_recommendation.csv' is in the same directory, this line should work.
df=pd.read_csv("Crop_recommendation.csv",sep=",",encoding="utf-8")
df1 = pd.read_csv("crop_yield.csv")
df1.head()
df2 = pd.read_csv("datafile (3).csv")
df2.head()
df3 = pd.read_csv("Crop_recommendation.csv")
df3.head()

import pandas as pd
pd.set_option("display.max_rows",None)
print(df)

import pandas as pd

# Assuming df, df1, df2, df3 are your DataFrames

# Set display options for all DataFrames
pd.set_option("display.max_columns", None)

# Print each DataFrame to display all columns
print("df:")
print(df)

print("\ndf1:")
print(df1)

print("\ndf2:")
print(df2)

print("\ndf3:")
print(df3)

import pandas as pd

# Load the CSV file
df = pd.read_csv("crop_yield.csv")

# Define a dictionary to map states to soil types
state_soil_map = {
    "Jammu & Kashmir": "Mountain Soil",
    "Himachal Pradesh": "Mountain Soil",
    "Uttarakhand": "Mountain Soil",
    "Punjab": "Alluvial Soil",
    "Haryana": "Alluvial Soil",
    "Uttar Pradesh": "Alluvial Soil",
    "Bihar": "Alluvial Soil",
    "West Bengal": "Alluvial Soil",
    "Jharkhand": "Red and Yellow Soil",
    "Odisha": "Red and Yellow Soil",
    "Assam": "Alluvial Soil",
    "Arunachal Pradesh": "Mountain Soil",
    "Manipur": "Mountain Soil",
    "Meghalaya": "Laterite Soil",
    "Mizoram": "Mountain Soil",
    "Nagaland": "Mountain Soil",
    "Tripura": "Alluvial Soil",
    "Sikkim": "Mountain Soil",
    "Rajasthan": "Desert Soil",
    "Gujarat": "Black Soil",
    "Maharashtra": "Black Soil",
    "Goa": "Laterite Soil",
    "Madhya Pradesh": "Black Soil",
    "Chhattisgarh": "Red and Yellow Soil",
    "Karnataka": "Red and Yellow Soil",
    "Kerala": "Laterite Soil",
    "Tamil Nadu": "Red and Yellow Soil",
    "Andhra Pradesh": "Black Soil",
    "Telangana": "Black Soil",
    "Delhi": "Alluvial Soil",
    "Puducherry": "Red and Yellow Soil",
    "Lakshadweep": "Coastal Sandy Soil",
    "Andaman & Nicobar Islands": "Coastal Sandy Soil",
    "Chandigarh": "Alluvial Soil",
    "Ladakh": "Mountain Soil",
    "Dadra & Nagar Haveli and Daman & Diu": "Black Soil"

    # Add more state-soil mappings as needed
}

# Create the new 'Soil Type' column based on the state
df["Soil_Type"] = df["State"].map(state_soil_map)

# Save the updated DataFrame to a new CSV file
df.to_csv("crop_yield_with_soil.csv", index=False)
df.head()

print(df.columns)

"""# Data Visualisation"""

# Basic scatter plot of Area vs Production
plt.figure(figsize=(8, 6))
plt.scatter(df['Area'], df['Production'])
plt.xlabel('Area')
plt.ylabel('Production')
plt.title('Area vs Production')
plt.show()

# Histogram of Yield
plt.figure(figsize=(8, 6))
plt.hist(df['Yield'], bins=20)
plt.xlabel('Yield')
plt.ylabel('Frequency')
plt.title('Distribution of Yield')
plt.show()

# Boxplot of Yield by Crop
plt.figure(figsize=(10, 6))
sns.boxplot(x='Crop', y='Yield', data=df)
plt.xlabel('Crop')
plt.ylabel('Yield')
plt.title('Yield Distribution by Crop')
plt.xticks(rotation=45, ha='right')
plt.show()

# Bar plot of Crop Production by State
crop_production_by_state = df.groupby('State')['Production'].sum()
plt.figure(figsize=(12, 6))
crop_production_by_state.plot(kind='bar')
plt.xlabel('State')
plt.ylabel('Total Production')
plt.title('Crop Production by State')
plt.xticks(rotation=45, ha='right')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Load the CSV file
df = pd.read_csv("datafile (3).csv")

# Assuming you want to plot 'column1' against 'column2'
# Replace 'column1' and 'column2' with the actual column names in your CSV file
plt.plot(df['Crop'], df['Variety'])
plt.xlabel('Crop')
plt.ylabel('Variety')
plt.title('Plot of Crop vs Variety')
plt.show()

# Load the CSV file
df3 = pd.read_csv("Crop_recommendation.csv")

# Scatter plot of temperature vs N
plt.figure(figsize=(8, 6))
plt.scatter(df3['temperature'], df3['N'])
plt.xlabel('Temperature')
plt.ylabel('Nitrogen')
plt.title('Temperature vs Nitrogen')
plt.show()

# Histogram of pH
plt.figure(figsize=(8, 6))
plt.hist(df3['ph'], bins=20)
plt.xlabel('pH')
plt.ylabel('Frequency')
plt.title('Distribution of pH')
plt.show()

# Boxplot of rainfall by label
plt.figure(figsize=(10, 6))
sns.boxplot(x='label', y='rainfall', data=df3)
plt.xlabel('Crop Label')
plt.ylabel('Rainfall')
plt.title('Rainfall Distribution by Crop')
plt.xticks(rotation=45, ha='right')
plt.show()

# Bar plot of crop label counts
crop_label_counts = df3['label'].value_counts()
plt.figure(figsize=(12, 6))
crop_label_counts.plot(kind='bar')
plt.xlabel('Crop Label')
plt.ylabel('Count')
plt.title('Crop Label Counts')
plt.xticks(rotation=45, ha='right')
plt.show()

# Pairplot to visualize relationships between multiple variables
sns.pairplot(df3[['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall']])
plt.show()

# Correlation matrix heatmap
correlation_matrix = df3[['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall']].corr()
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()

"""# Spiliting data into traning and testing sets"""

# Splitting data for df1 (crop_yield.csv)
X1 = df1.drop('Yield', axis=1)  # Features
y1 = df1['Yield']  # Target variable

X1_train, X1_test, y1_train, y1_test = train_test_split(X1, y1, test_size=0.2, random_state=42)

# Splitting data for df2 (datafile (3).csv)
# Assuming you want to predict 'Variety' based on 'Crop'
X2 = df2[['Crop','Season/ duration in days','Recommended Zone']]  # Features
y2 = df2['Variety']  # Target variable

X2_train, X2_test, y2_train, y2_test = train_test_split(X2, y2, test_size=0.2, random_state=42)

# Splitting data for df3 (Crop_recommendation.csv)
# Assuming you want to predict 'label' based on other features
X3 = df3.drop(['N','P','K','temperature','ph','rainfall'], axis=1)  # Features
y3 = df3['label']  # Target variable

X3_train, X3_test, y3_train, y3_test = train_test_split(X3, y3, test_size=0.2, random_state=42)

"""# Data training and testing"""

# Convert string columns to numerical using one-hot encoding
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer

# Assuming 'Crop', 'Season', 'State_Name', 'District_Name' are string columns
categorical_features = ['Crop', 'Season']

# Create a ColumnTransformer to apply OneHotEncoder to categorical features
preprocessor = ColumnTransformer(
    transformers=[
        ('num', 'passthrough', ['Crop_Year', 'Area', 'Production']),  # Keep numerical features
        ('cat', OneHotEncoder(sparse_output=False, handle_unknown='ignore'), categorical_features) #One-hot encode categorical features
    ])

# Apply the preprocessor to your data
X1 = preprocessor.fit_transform(df1.drop('Yield', axis=1)) #Transform the features
y1 = df1['Yield']  # Target variable

# Split the data into training and testing sets
X1_train, X1_test, y1_train, y1_test = train_test_split(X1, y1, test_size=0.2, random_state=42)

# Now you can train your Linear Regression model
model1 = LinearRegression()
model1.fit(X1_train, y1_train)

# Assuming df2 is your DataFrame from 'datafile (3).csv'

# Assuming 'Recommended Zone' is your target variable
X = df2.drop('Recommended Zone', axis=1)  # Features
y = df2['Recommended Zone']  # Target variable

# Convert categorical features to numerical using one-hot encoding
categorical_features = ['Crop', 'Variety', 'Season/ duration in days']  # Replace with your actual categorical features
preprocessor = ColumnTransformer(
    transformers=[
        ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_features)
    ], remainder='passthrough'
)
X_encoded = preprocessor.fit_transform(X)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_encoded, y, test_size=0.2, random_state=42)

# Print the shapes of the training and testing sets
print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)
print("X_test shape:", X_test.shape)
print("y_test shape:", y_test.shape)

# Splitting data for df3 (Crop_recommendation.csv)
X = df3.drop('label', axis=1)  # Features
y = df3['label']  # Target variable

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a Random Forest Classifier
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model
print("Accuracy:", accuracy_score(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred, color='blue', label='Predicted vs Actual')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], color='red', linestyle='--', label='Perfect Prediction')
plt.xlabel('Actual Yield')
plt.ylabel('Predicted Yield')
plt.title('Actual vs Predicted Yield (Random Forest Regression)')
plt.legend()
plt.show()

# Assuming you have X_train, X_test, y_train, y_test from your code
# You can replace these with your own training and testing data

plt.figure(figsize=(10, 6))
plt.plot(y_train, label='Training Data')
plt.plot(y_test, label='Testing Data')
plt.xlabel('Data Point Index')
plt.ylabel('Yield')
plt.title('Training and Testing Data for datafile (3).csv')
plt.legend()
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(y_train, label='Training Data')
plt.plot(y_test, label='Testing Data')
plt.xlabel('Data Point Index')
plt.ylabel('Target Variable (label)')
plt.title('Training and Testing Data for Crop_recommendation.csv')
plt.legend()
plt.show()

"""# **FINAL OUTCOME**"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import mean_squared_error, r2_score

# Load the dataset
#df = pd.read_csv("crop_yield.csv")
df = pd.read_csv("crop_yield_with_soil.csv")
print(df.columns)

# Select relevant features and target variable
features = ['Crop', 'Season', 'State', 'Soil_Type', 'Area']
target = 'Yield'

X = df[features]
y = df[target]

# Create LabelEncoders for categorical features
label_encoders = {}
for feature in ['Crop', 'Season', 'State', 'Soil_Type']:
    label_encoders[feature] = LabelEncoder()
    # Fit the LabelEncoder on all unique values in the column,
    # including those in the test set
    label_encoders[feature].fit(pd.concat([df[feature], pd.Series(['Rabi'])], ignore_index=True))
    X[feature] = label_encoders[feature].transform(X[feature])

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a RandomForestRegressor model
model = RandomForestRegressor(n_estimators=100, random_state=42)  # You can adjust hyperparameters
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")


def predict_yield(crop, season, state, soil_type, area):
    # Create a DataFrame for the input data
    input_data = pd.DataFrame({
        'Crop': [crop],
        'Season': [season],
        'State': [state],
        'Soil_Type': [soil_type],
        'Area': [area]
    })

    # Apply label encoding to the input data
    for feature in ['Crop', 'Season', 'State', 'Soil_Type']:
        input_data[feature] = label_encoders[feature].transform(input_data[feature])

    # Make prediction
    predicted_yield = model.predict(input_data)[0]
    return predicted_yield

# Example usage
predicted_yield = predict_yield('Rice', 'Rabi', 'West Bengal', 'Alluvial Soil', 1000)
print(f"Predicted Yield: {predicted_yield}")

# prompt: make a dynamic program to predict recommended_zone in which inputs are Crop and Variety on the basis of above training of datafile (3).csv

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.preprocessing import LabelEncoder

# Load the dataset
df2 = pd.read_csv("datafile (3).csv")

# Prepare the data
X = df2[['Crop', 'Variety']]
y = df2['Recommended Zone']

# Encode categorical features using Label Encoding
le_crop = LabelEncoder()
le_variety = LabelEncoder()
le_zone = LabelEncoder()

X['Crop'] = le_crop.fit_transform(X['Crop'])
X['Variety'] = le_variety.fit_transform(X['Variety'])
y = le_zone.fit_transform(y)

# Split the data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a RandomForestClassifier
model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate the model
print("Accuracy:", accuracy_score(y_test, y_pred))
print(classification_report(y_test, y_pred))


def predict_recommended_zone(crop, variety):
    # Encode the input using the trained LabelEncoders
    crop_encoded = le_crop.transform([crop])[0]
    variety_encoded = le_variety.transform([variety])[0]

    # Make the prediction
    prediction = model.predict([[crop_encoded, variety_encoded]])[0]

    # Decode the prediction back to the original zone name
    recommended_zone = le_zone.inverse_transform([prediction])[0]
    return recommended_zone

# Example usage:
crop_name = "Oat" #@param {type:"string"}
variety_name = "OS 346" #@param {type:"string"}
predicted_zone = predict_recommended_zone(crop_name, variety_name)
print(f"The recommended zone for {variety_name} {crop_name} is: {predicted_zone}")

# prompt: make a dynamic program to predict label (crop) in which inputs are N , P , K , temperature , ph , rainfall , humidity on the basis of above training of Crop_recommendation.csv

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, classification_report

# Load the dataset
df3 = pd.read_csv("Crop_recommendation.csv")

# Prepare the data
X = df3[['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall']]
y = df3['label']

# Split the data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a RandomForestClassifier
model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate the model
print("Accuracy:", accuracy_score(y_test, y_pred))
print(classification_report(y_test, y_pred))


def predict_crop(N, P, K, temperature, humidity, ph, rainfall):
    prediction = model.predict([[N, P, K, temperature, humidity, ph, rainfall]])[0]
    return prediction

# Example usage with input fields:
N_input = 93 #@param {type:"number"}
P_input = 56 #@param {type:"number"}
K_input = 36 #@param {type:"number"}
temperature_input = 24.879744 #@param {type:"number"}
humidity_input = 82.002744 #@param {type:"number"}
ph_input = 6.502985 #@param {type:"number"}
rainfall_input = 185.935536 #@param {type:"number"}

predicted_crop = predict_crop(N_input, P_input, K_input, temperature_input, humidity_input, ph_input, rainfall_input)
print(f"The predicted crop is: {predicted_crop}")